// NOTE this file is auto-generated by chew
module wren

import wren.c

pub const used_import = c.used_import

//
// wren.h
//

// C typedef aliases used

/*
TODO Non-numerical: #define wren_h
*/

// // The Wren semantic version number components.
pub const version_major = 0

pub const version_minor = 4

pub const version_patch = 0

pub const version_string = '${version_major}.${version_minor}.$version_patch'

/*
TODO Function: #define WREN_VERSION_NUMBER (WREN_VERSION_MAJOR * 1000000 +                    \
*/
// A single virtual machine for executing Wren code.
//
// Wren has no global state, so all state stored by a running interpreter lives
// here.
[typedef]
pub struct C.WrenVM {}

pub type VM = C.WrenVM

// A handle to a Wren object.
//
// This lets code outside of the VM hold a persistent reference to an object.
// After a handle is acquired, and until it is released, this ensures the
// garbage collector will not reclaim the object it references.
[typedef]
pub struct C.WrenHandle {}

pub type Handle = C.WrenHandle

// ReallocateFn A generic allocation function that handles all explicit memory management
// ReallocateFn used by Wren. It's used like so:
// - To allocate new memory, `memory` is NULL and `newSize` is the desired
//   size. It should return the allocated memory or NULL on failure.
// - To attempt to grow an existing allocation, `memory` is the memory, and
//   `newSize` is the desired size. It should return `memory` if it was able to
//   grow it in place, or a new pointer if it had to move it.
// - To shrink memory, `memory` and `newSize` are the same as above but it will
//   always return `memory`.
// - To free memory, `memory` will be the memory to free and `newSize` will be
//   zero. It should return NULL.
// C: typedef void* (*WrenReallocateFn)(void* memory, size_t newSize, void* userData);
pub type ReallocateFn = fn (memory voidptr, new_size usize, user_data voidptr) voidptr

// ForeignMethodFn A function callable from Wren code, but implemented in C.
// C: typedef void (*WrenForeignMethodFn)(WrenVM* vm);
pub type ForeignMethodFn = fn (vm &VM)

// FinalizerFn A finalizer function for freeing resources owned by an instance of a foreign
// FinalizerFn class. Unlike most foreign methods, finalizers do not have access to the VM
// and should not interact with it since it's in the middle of a garbage
// collection.
// C: typedef void (*WrenFinalizerFn)(void* data);
pub type FinalizerFn = fn (data voidptr)

// Gives the host a chance to canonicalize the imported module name,
// potentially taking into account the (previously resolved) name of the module
// that contains the import. Typically, this is used to implement relative
// imports.
// C: typedef const char* (*WrenResolveModuleFn)(WrenVM* vm, const char* importer, const char* name);
pub type ResolveModuleFn = fn (vm &VM, const_importer &char, const_name &char)

// LoadModuleCompleteFn Called after loadModuleFn is called for module `name`. The original returned result
// LoadModuleCompleteFn is handed back to you in this callback, so that you can free memory if appropriate.
// C: typedef void (*WrenLoadModuleCompleteFn)(WrenVM* vm, const char* name, struct WrenLoadModuleResult result);
pub type LoadModuleCompleteFn = fn (vm &VM, const_name &char, result LoadModuleResult)

[typedef]
pub struct C.WrenLoadModuleResult {
pub mut:
	source &char = unsafe { nil }

	onComplete LoadModuleCompleteFn

	userData voidptr
}

pub type LoadModuleResult = C.WrenLoadModuleResult

// LoadModuleFn Loads and returns the source code for the module `name`.
// C: typedef WrenLoadModuleResult (*WrenLoadModuleFn)(WrenVM* vm, const char* name);
pub type LoadModuleFn = fn (vm &VM, const_name &char) LoadModuleResult

// ForeignMethodFn Returns a pointer to a foreign method on `className` in `module` with
// `signature`.
// C: typedef WrenForeignMethodFn (*WrenBindForeignMethodFn)(WrenVM* vm, const char* module, const char* className, bool isStatic, const char* signature);
pub type BindForeignMethodFn = fn (vm &VM, const_module &char, const_class_name &char, is_static bool, const_signature &char) ForeignMethodFn

// WriteFn Displays a string of text to the user.
// C: typedef void (*WrenWriteFn)(WrenVM* vm, const char* text);
pub type WriteFn = fn (vm &VM, const_text &char)

// WrenErrorType is C.WrenErrorType
pub enum ErrorType {
	// A syntax or resolution error detected at compile time.
	compile = C.WREN_ERROR_COMPILE
	// The error message for a runtime error.
	runtime = C.WREN_ERROR_RUNTIME
	// One entry of a runtime error's stack trace.
	stack_trace = C.WREN_ERROR_STACK_TRACE
}

// Reports an error to the user.
//
// An error detected during compile time is reported by calling this once with
// `type` `WREN_ERROR_COMPILE`, the resolved name of the `module` and `line`
// where the error occurs, and the compiler's error `message`.
//
// A runtime error is reported by calling this once with `type`
// `WREN_ERROR_RUNTIME`, no `module` or `line`, and the runtime error's
// `message`. After that, a series of `type` `WREN_ERROR_STACK_TRACE` calls are
// made for each line in the stack trace. Each of those has the resolved
// `module` and `line` where the method or function is defined and `message` is
// the name of the method or function.
// C: typedef void (*WrenErrorFn)(WrenVM* vm, WrenErrorType type, const char* module, int line,  const char* message);
pub type ErrorFn = fn (vm &VM, typ ErrorType, const_module &char, line int, const_message &char)

[typedef]
pub struct C.WrenForeignClassMethods {
pub mut:
	// The callback invoked when the foreign object is created.
	//
	// This must be provided. Inside the body of this, it must call
	// `wrenSetSlotNewForeign()` exactly once.
	//
	allocate ForeignMethodFn
	// The callback invoked when the garbage collector is about to collect a
	// foreign object's memory.
	//
	// This may be `NULL` if the foreign class does not need to finalize.
	//

	finalize FinalizerFn
}

pub type ForeignClassMethods = C.WrenForeignClassMethods

// Returns a pair of pointers to the foreign methods used to allocate and
// finalize the data for instances of `className` in resolved `module`.
// C: typedef WrenForeignClassMethods (*WrenBindForeignClassFn)(WrenVM* vm, const char* module, const char* className);
pub type BindForeignClassFn = fn (vm &VM, const_module &char, const_class_name &char) ForeignClassMethods

[typedef]
pub struct C.WrenConfiguration {
pub mut:
	// The callback Wren will use to allocate, reallocate, and deallocate memory.
	//
	// If `NULL`, defaults to a built-in function that uses `realloc` and `free`.
	//
	reallocateFn ReallocateFn
	// The callback Wren uses to resolve a module name.
	//
	// Some host applications may wish to support "relative" imports, where the
	// meaning of an import string depends on the module that contains it. To
	// support that without baking any policy into Wren itself, the VM gives the
	// host a chance to resolve an import string.
	//
	// Before an import is loaded, it calls this, passing in the name of the
	// module that contains the import and the import string. The host app can
	// look at both of those and produce a new "canonical" string that uniquely
	// identifies the module. This string is then used as the name of the module
	// going forward. It is what is passed to `loadModuleFn`, how duplicate
	// imports of the same module are detected, and how the module is reported in
	// stack traces.
	//
	// If you leave this function NULL, then the original import string is
	// treated as the resolved string.
	//
	// If an import cannot be resolved by the embedder, it should return NULL and
	// Wren will report that as a runtime error.
	//
	// Wren will take ownership of the string you return and free it for you, so
	// it should be allocated using the same allocation function you provide
	// above.
	//

	resolveModuleFn ResolveModuleFn
	// The callback Wren uses to load a module.
	//
	// Since Wren does not talk directly to the file system, it relies on the
	// embedder to physically locate and read the source code for a module. The
	// first time an import appears, Wren will call this and pass in the name of
	// the module being imported. The method will return a result, which contains
	// the source code for that module. Memory for the source is owned by the
	// host application, and can be freed using the onComplete callback.
	//
	// This will only be called once for any given module name. Wren caches the
	// result internally so subsequent imports of the same module will use the
	// previous source and not call this.
	//
	// If a module with the given name could not be found by the embedder, it
	// should return NULL and Wren will report that as a runtime error.
	//

	loadModuleFn LoadModuleFn
	// The callback Wren uses to find a foreign method and bind it to a class.
	//
	// When a foreign method is declared in a class, this will be called with the
	// foreign method's module, class, and signature when the class body is
	// executed. It should return a pointer to the foreign function that will be
	// bound to that method.
	//
	// If the foreign function could not be found, this should return NULL and
	// Wren will report it as runtime error.
	//

	bindForeignMethodFn BindForeignMethodFn
	// The callback Wren uses to find a foreign class and get its foreign methods.
	//
	// When a foreign class is declared, this will be called with the class's
	// module and name when the class body is executed. It should return the
	// foreign functions uses to allocate and (optionally) finalize the bytes
	// stored in the foreign object when an instance is created.
	//

	bindForeignClassFn BindForeignClassFn
	// The callback Wren uses to display text when `System.print()` or the other
	// related functions are called.
	//
	// If this is `NULL`, Wren discards any printed text.
	//

	writeFn WriteFn
	// The callback Wren uses to report errors.
	//
	// When an error occurs, this will be called with the module name, line
	// number, and an error message. If this is `NULL`, Wren doesn't report any
	// errors.
	//

	errorFn ErrorFn
	// The number of bytes Wren will allocate before triggering the first garbage
	// collection.
	//
	// If zero, defaults to 10MB.
	//

	initialHeapSize usize
	// After a collection occurs, the threshold for the next collection is
	// determined based on the number of bytes remaining in use. This allows Wren
	// to shrink its memory usage automatically after reclaiming a large amount
	// of memory.
	//
	// This can be used to ensure that the heap does not get too small, which can
	// in turn lead to a large number of collections afterwards as the heap grows
	// back to a usable size.
	//
	// If zero, defaults to 1MB.
	//

	minHeapSize usize
	// Wren will resize the heap automatically as the number of bytes
	// remaining in use after a collection changes. This number determines the
	// amount of additional memory Wren will use after a collection, as a
	// percentage of the current heap size.
	//
	// For example, say that this is 50. After a garbage collection, when there
	// are 400 bytes of memory still in use, the next collection will be triggered
	// after a total of 600 bytes are allocated (including the 400 already in
	// use.)
	//
	// Setting this to a smaller number wastes less memory, but triggers more
	// frequent garbage collections.
	//
	// If zero, defaults to 50.
	//

	heapGrowthPercent int
	// User-defined data associated with the VM.
	//

	userData voidptr
}

pub type Configuration = C.WrenConfiguration

// WrenInterpretResult is C.WrenInterpretResult
pub enum WrenInterpretResult {
	success = C.WREN_RESULT_SUCCESS
	compile_error = C.WREN_RESULT_COMPILE_ERROR
	runtime_error = C.WREN_RESULT_RUNTIME_ERROR
}

// WrenType is C.WrenType
pub enum WrenType {
	bool = C.WREN_TYPE_BOOL
	num = C.WREN_TYPE_NUM
	foreign = C.WREN_TYPE_FOREIGN
	list = C.WREN_TYPE_LIST
	map = C.WREN_TYPE_MAP
	null = C.WREN_TYPE_NULL
	string = C.WREN_TYPE_STRING
	// The object is of a type that isn't accessible by the C API.
	unknown = C.WREN_TYPE_UNKNOWN
}

// C: `WREN_API int wrenGetVersionNumber()`
fn C.wrenGetVersionNumber() int

// get_version_number Get the current wren version number.
// get_version_number Can be used to range checks over versions.
pub fn get_version_number() int {
	return C.wrenGetVersionNumber()
}

// C: `WREN_API void wrenInitConfiguration(WrenConfiguration* configuration)`
fn C.wrenInitConfiguration(configuration &Configuration)

// init_configuration Initializes `configuration` with all of its default values.
// init_configuration Call this before setting the particular fields you care about.
pub fn init_configuration(configuration &Configuration) {
	C.wrenInitConfiguration(configuration)
}

// C: `WREN_API WrenVM* wrenNewVM(WrenConfiguration* configuration)`
fn C.wrenNewVM(configuration &Configuration) &C.WrenVM

// new_vm Creates a new Wren virtual machine using the given `configuration`. Wren
// new_vm will copy the configuration data, so the argument passed to this can be
// freed after calling this. If `configuration` is `NULL`, uses a default
// configuration.
pub fn new_vm(configuration &Configuration) &VM {
	return C.wrenNewVM(configuration)
}

// C: `WREN_API void wrenFreeVM(WrenVM* vm)`
fn C.wrenFreeVM(vm &C.WrenVM)

// free_vm Disposes of all resources is use by `vm`, which was previously created by a
// free_vm call to `wrenNewVM`.
pub fn free_vm(vm &VM) {
	C.wrenFreeVM(vm)
}

// C: `WREN_API void wrenCollectGarbage(WrenVM* vm)`
fn C.wrenCollectGarbage(vm &C.WrenVM)

// collect_garbage Immediately run the garbage collector to free unused memory.
pub fn collect_garbage(vm &VM) {
	C.wrenCollectGarbage(vm)
}

// C: `WREN_API WrenInterpretResult wrenInterpret(WrenVM* vm, const char* module, const char* source)`
fn C.wrenInterpret(vm &C.WrenVM, const_module &char, const_source &char) WrenInterpretResult

// interpret Runs `source`, a string of Wren source code in a new fiber in `vm` in the
// interpret context of resolved `module`.
pub fn interpret(vm &VM, const_module &char, const_source &char) WrenInterpretResult {
	return C.wrenInterpret(vm, const_module, const_source)
}

// C: `WREN_API WrenHandle* wrenMakeCallHandle(WrenVM* vm, const char* signature)`
fn C.wrenMakeCallHandle(vm &C.WrenVM, const_signature &char) &C.WrenHandle

// make_call_handle Creates a handle that can be used to invoke a method with `signature` on
// make_call_handle using a receiver and arguments that are set up on the stack.
// This handle can be used repeatedly to directly invoke that method from C
// code using `wrenCall`.
// When you are done with this handle, it must be released using
// `wrenReleaseHandle`.
pub fn make_call_handle(vm &VM, const_signature &char) &Handle {
	return C.wrenMakeCallHandle(vm, const_signature)
}

// C: `WREN_API WrenInterpretResult wrenCall(WrenVM* vm, WrenHandle* method)`
fn C.wrenCall(vm &C.WrenVM, method &C.WrenHandle) WrenInterpretResult

// call Calls `method`, using the receiver and arguments previously set up on the
// call stack.
// `method` must have been created by a call to `wrenMakeCallHandle`. The
// arguments to the method must be already on the stack. The receiver should be
// in slot 0 with the remaining arguments following it, in order. It is an
// error if the number of arguments provided does not match the method's
// signature.
// After this returns, you can access the return value from slot 0 on the stack.
pub fn call(vm &VM, method &Handle) WrenInterpretResult {
	return C.wrenCall(vm, method)
}

// C: `WREN_API void wrenReleaseHandle(WrenVM* vm, WrenHandle* handle)`
fn C.wrenReleaseHandle(vm &C.WrenVM, handle &C.WrenHandle)

// release_handle Releases the reference stored in `handle`. After calling this, `handle` can
// release_handle no longer be used.
pub fn release_handle(vm &VM, handle &Handle) {
	C.wrenReleaseHandle(vm, handle)
}

// C: `WREN_API int wrenGetSlotCount(WrenVM* vm)`
fn C.wrenGetSlotCount(vm &C.WrenVM) int

// get_slot_count Returns the number of slots available to the current foreign method.
pub fn get_slot_count(vm &VM) int {
	return C.wrenGetSlotCount(vm)
}

// C: `WREN_API void wrenEnsureSlots(WrenVM* vm, int numSlots)`
fn C.wrenEnsureSlots(vm &C.WrenVM, num_slots int)

// ensure_slots Ensures that the foreign method stack has at least `numSlots` available for
// ensure_slots use, growing the stack if needed.
// Does not shrink the stack if it has more than enough slots.
// It is an error to call this from a finalizer.
pub fn ensure_slots(vm &VM, num_slots int) {
	C.wrenEnsureSlots(vm, num_slots)
}

// C: `WREN_API WrenType wrenGetSlotType(WrenVM* vm, int slot)`
fn C.wrenGetSlotType(vm &C.WrenVM, slot int) WrenType

// get_slot_type Gets the type of the object in `slot`.
pub fn get_slot_type(vm &VM, slot int) WrenType {
	return C.wrenGetSlotType(vm, slot)
}

// C: `WREN_API bool wrenGetSlotBool(WrenVM* vm, int slot)`
fn C.wrenGetSlotBool(vm &C.WrenVM, slot int) bool

// get_slot_bool Reads a boolean value from `slot`.
// get_slot_bool It is an error to call this if the slot does not contain a boolean value.
pub fn get_slot_bool(vm &VM, slot int) bool {
	return C.wrenGetSlotBool(vm, slot)
}

// C: `WREN_API const char* wrenGetSlotBytes(WrenVM* vm, int slot, int* length)`
fn C.wrenGetSlotBytes(vm &C.WrenVM, slot int, length &int) &char

// get_slot_bytes Reads a byte array from `slot`.
// get_slot_bytes The memory for the returned string is owned by Wren. You can inspect it
// while in your foreign method, but cannot keep a pointer to it after the
// function returns, since the garbage collector may reclaim it.
// Returns a pointer to the first byte of the array and fill `length` with the
// number of bytes in the array.
// It is an error to call this if the slot does not contain a string.
pub fn get_slot_bytes(vm &VM, slot int, length &int) &char {
	return C.wrenGetSlotBytes(vm, slot, length)
}

// C: `WREN_API double wrenGetSlotDouble(WrenVM* vm, int slot)`
fn C.wrenGetSlotDouble(vm &C.WrenVM, slot int) f64

// get_slot_double Reads a number from `slot`.
// get_slot_double It is an error to call this if the slot does not contain a number.
pub fn get_slot_double(vm &VM, slot int) f64 {
	return C.wrenGetSlotDouble(vm, slot)
}

// C: `WREN_API void* wrenGetSlotForeign(WrenVM* vm, int slot)`
fn C.wrenGetSlotForeign(vm &C.WrenVM, slot int) voidptr

// get_slot_foreign Reads a foreign object from `slot` and returns a pointer to the foreign data
// get_slot_foreign stored with it.
// It is an error to call this if the slot does not contain an instance of a
// foreign class.
pub fn get_slot_foreign(vm &VM, slot int) voidptr {
	return C.wrenGetSlotForeign(vm, slot)
}

// C: `WREN_API const char* wrenGetSlotString(WrenVM* vm, int slot)`
fn C.wrenGetSlotString(vm &C.WrenVM, slot int) &char

// get_slot_string Reads a string from `slot`.
// get_slot_string The memory for the returned string is owned by Wren. You can inspect it
// while in your foreign method, but cannot keep a pointer to it after the
// function returns, since the garbage collector may reclaim it.
// It is an error to call this if the slot does not contain a string.
pub fn get_slot_string(vm &VM, slot int) &char {
	return C.wrenGetSlotString(vm, slot)
}

// C: `WREN_API WrenHandle* wrenGetSlotHandle(WrenVM* vm, int slot)`
fn C.wrenGetSlotHandle(vm &C.WrenVM, slot int) &C.WrenHandle

// get_slot_handle Creates a handle for the value stored in `slot`.
// get_slot_handle This will prevent the object that is referred to from being garbage collected
// until the handle is released by calling `wrenReleaseHandle()`.
pub fn get_slot_handle(vm &VM, slot int) &Handle {
	return C.wrenGetSlotHandle(vm, slot)
}

// C: `WREN_API void wrenSetSlotBool(WrenVM* vm, int slot, bool value)`
fn C.wrenSetSlotBool(vm &C.WrenVM, slot int, value bool)

// set_slot_bool Stores the boolean `value` in `slot`.
pub fn set_slot_bool(vm &VM, slot int, value bool) {
	C.wrenSetSlotBool(vm, slot, value)
}

// C: `WREN_API void wrenSetSlotBytes(WrenVM* vm, int slot, const char* bytes, size_t length)`
fn C.wrenSetSlotBytes(vm &C.WrenVM, slot int, const_bytes &char, length usize)

// set_slot_bytes Stores the array `length` of `bytes` in `slot`.
// set_slot_bytes The bytes are copied to a new string within Wren's heap, so you can free
// memory used by them after this is called.
pub fn set_slot_bytes(vm &VM, slot int, const_bytes &char, length usize) {
	C.wrenSetSlotBytes(vm, slot, const_bytes, length)
}

// C: `WREN_API void wrenSetSlotDouble(WrenVM* vm, int slot, double value)`
fn C.wrenSetSlotDouble(vm &C.WrenVM, slot int, value f64)

// set_slot_double Stores the numeric `value` in `slot`.
pub fn set_slot_double(vm &VM, slot int, value f64) {
	C.wrenSetSlotDouble(vm, slot, value)
}

// C: `WREN_API void* wrenSetSlotNewForeign(WrenVM* vm, int slot, int classSlot, size_t size)`
fn C.wrenSetSlotNewForeign(vm &C.WrenVM, slot int, class_slot int, size usize) voidptr

// set_slot_new_foreign Creates a new instance of the foreign class stored in `classSlot` with `size`
// set_slot_new_foreign bytes of raw storage and places the resulting object in `slot`.
// This does not invoke the foreign class's constructor on the new instance. If
// you need that to happen, call the constructor from Wren, which will then
// call the allocator foreign method. In there, call this to create the object
// and then the constructor will be invoked when the allocator returns.
// Returns a pointer to the foreign object's data.
pub fn set_slot_new_foreign(vm &VM, slot int, class_slot int, size usize) voidptr {
	return C.wrenSetSlotNewForeign(vm, slot, class_slot, size)
}

// C: `WREN_API void wrenSetSlotNewList(WrenVM* vm, int slot)`
fn C.wrenSetSlotNewList(vm &C.WrenVM, slot int)

// set_slot_new_list Stores a new empty list in `slot`.
pub fn set_slot_new_list(vm &VM, slot int) {
	C.wrenSetSlotNewList(vm, slot)
}

// C: `WREN_API void wrenSetSlotNewMap(WrenVM* vm, int slot)`
fn C.wrenSetSlotNewMap(vm &C.WrenVM, slot int)

// set_slot_new_map Stores a new empty map in `slot`.
pub fn set_slot_new_map(vm &VM, slot int) {
	C.wrenSetSlotNewMap(vm, slot)
}

// C: `WREN_API void wrenSetSlotNull(WrenVM* vm, int slot)`
fn C.wrenSetSlotNull(vm &C.WrenVM, slot int)

// set_slot_null Stores null in `slot`.
pub fn set_slot_null(vm &VM, slot int) {
	C.wrenSetSlotNull(vm, slot)
}

// C: `WREN_API void wrenSetSlotString(WrenVM* vm, int slot, const char* text)`
fn C.wrenSetSlotString(vm &C.WrenVM, slot int, const_text &char)

// set_slot_string Stores the string `text` in `slot`.
// set_slot_string The `text` is copied to a new string within Wren's heap, so you can free
// memory used by it after this is called. The length is calculated using
// `strlen()`. If the string may contain any null bytes in the middle, then you
// should use `wrenSetSlotBytes()` instead.
pub fn set_slot_string(vm &VM, slot int, const_text &char) {
	C.wrenSetSlotString(vm, slot, const_text)
}

// C: `WREN_API void wrenSetSlotHandle(WrenVM* vm, int slot, WrenHandle* handle)`
fn C.wrenSetSlotHandle(vm &C.WrenVM, slot int, handle &C.WrenHandle)

// set_slot_handle Stores the value captured in `handle` in `slot`.
// set_slot_handle This does not release the handle for the value.
pub fn set_slot_handle(vm &VM, slot int, handle &Handle) {
	C.wrenSetSlotHandle(vm, slot, handle)
}

// C: `WREN_API int wrenGetListCount(WrenVM* vm, int slot)`
fn C.wrenGetListCount(vm &C.WrenVM, slot int) int

// get_list_count Returns the number of elements in the list stored in `slot`.
pub fn get_list_count(vm &VM, slot int) int {
	return C.wrenGetListCount(vm, slot)
}

// C: `WREN_API void wrenGetListElement(WrenVM* vm, int listSlot, int index, int elementSlot)`
fn C.wrenGetListElement(vm &C.WrenVM, list_slot int, index int, element_slot int)

// get_list_element Reads element `index` from the list in `listSlot` and stores it in
// get_list_element `elementSlot`.
pub fn get_list_element(vm &VM, list_slot int, index int, element_slot int) {
	C.wrenGetListElement(vm, list_slot, index, element_slot)
}

// C: `WREN_API void wrenSetListElement(WrenVM* vm, int listSlot, int index, int elementSlot)`
fn C.wrenSetListElement(vm &C.WrenVM, list_slot int, index int, element_slot int)

// set_list_element Sets the value stored at `index` in the list at `listSlot`,
// set_list_element to the value from `elementSlot`.
pub fn set_list_element(vm &VM, list_slot int, index int, element_slot int) {
	C.wrenSetListElement(vm, list_slot, index, element_slot)
}

// C: `WREN_API void wrenInsertInList(WrenVM* vm, int listSlot, int index, int elementSlot)`
fn C.wrenInsertInList(vm &C.WrenVM, list_slot int, index int, element_slot int)

// insert_in_list Takes the value stored at `elementSlot` and inserts it into the list stored
// insert_in_list at `listSlot` at `index`.
// As in Wren, negative indexes can be used to insert from the end. To append
// an element, use `-1` for the index.
pub fn insert_in_list(vm &VM, list_slot int, index int, element_slot int) {
	C.wrenInsertInList(vm, list_slot, index, element_slot)
}

// C: `WREN_API int wrenGetMapCount(WrenVM* vm, int slot)`
fn C.wrenGetMapCount(vm &C.WrenVM, slot int) int

// get_map_count Returns the number of entries in the map stored in `slot`.
pub fn get_map_count(vm &VM, slot int) int {
	return C.wrenGetMapCount(vm, slot)
}

// C: `WREN_API bool wrenGetMapContainsKey(WrenVM* vm, int mapSlot, int keySlot)`
fn C.wrenGetMapContainsKey(vm &C.WrenVM, map_slot int, key_slot int) bool

// get_map_contains_key Returns true if the key in `keySlot` is found in the map placed in `mapSlot`.
pub fn get_map_contains_key(vm &VM, map_slot int, key_slot int) bool {
	return C.wrenGetMapContainsKey(vm, map_slot, key_slot)
}

// C: `WREN_API void wrenGetMapValue(WrenVM* vm, int mapSlot, int keySlot, int valueSlot)`
fn C.wrenGetMapValue(vm &C.WrenVM, map_slot int, key_slot int, value_slot int)

// get_map_value Retrieves a value with the key in `keySlot` from the map in `mapSlot` and
// get_map_value stores it in `valueSlot`.
pub fn get_map_value(vm &VM, map_slot int, key_slot int, value_slot int) {
	C.wrenGetMapValue(vm, map_slot, key_slot, value_slot)
}

// C: `WREN_API void wrenSetMapValue(WrenVM* vm, int mapSlot, int keySlot, int valueSlot)`
fn C.wrenSetMapValue(vm &C.WrenVM, map_slot int, key_slot int, value_slot int)

// set_map_value Takes the value stored at `valueSlot` and inserts it into the map stored
// set_map_value at `mapSlot` with key `keySlot`.
pub fn set_map_value(vm &VM, map_slot int, key_slot int, value_slot int) {
	C.wrenSetMapValue(vm, map_slot, key_slot, value_slot)
}

// C: `WREN_API void wrenRemoveMapValue(WrenVM* vm, int mapSlot, int keySlot, int removedValueSlot)`
fn C.wrenRemoveMapValue(vm &C.WrenVM, map_slot int, key_slot int, removed_value_slot int)

// remove_map_value Removes a value from the map in `mapSlot`, with the key from `keySlot`,
// remove_map_value and place it in `removedValueSlot`. If not found, `removedValueSlot` is
// set to null, the same behaviour as the Wren Map API.
pub fn remove_map_value(vm &VM, map_slot int, key_slot int, removed_value_slot int) {
	C.wrenRemoveMapValue(vm, map_slot, key_slot, removed_value_slot)
}

// C: `WREN_API void wrenGetVariable(WrenVM* vm, const char* module, const char* name,int slot)`
fn C.wrenGetVariable(vm &C.WrenVM, const_module &char, const_name &char, slot int)

// get_variable Looks up the top level variable with `name` in resolved `module` and stores
// get_variable it in `slot`.
pub fn get_variable(vm &VM, const_module &char, const_name &char, slot int) {
	C.wrenGetVariable(vm, const_module, const_name, slot)
}

// C: `WREN_API bool wrenHasVariable(WrenVM* vm, const char* module, const char* name)`
fn C.wrenHasVariable(vm &C.WrenVM, const_module &char, const_name &char) bool

// has_variable Looks up the top level variable with `name` in resolved `module`,
// has_variable returns false if not found. The module must be imported at the time,
// use wrenHasModule to ensure that before calling.
pub fn has_variable(vm &VM, const_module &char, const_name &char) bool {
	return C.wrenHasVariable(vm, const_module, const_name)
}

// C: `WREN_API bool wrenHasModule(WrenVM* vm, const char* module)`
fn C.wrenHasModule(vm &C.WrenVM, const_module &char) bool

// has_module Returns true if `module` has been imported/resolved before, false if not.
pub fn has_module(vm &VM, const_module &char) bool {
	return C.wrenHasModule(vm, const_module)
}

// C: `WREN_API void wrenAbortFiber(WrenVM* vm, int slot)`
fn C.wrenAbortFiber(vm &C.WrenVM, slot int)

// abort_fiber Sets the current fiber to be aborted, and uses the value in `slot` as the
// abort_fiber runtime error object.
pub fn abort_fiber(vm &VM, slot int) {
	C.wrenAbortFiber(vm, slot)
}

// C: `WREN_API void* wrenGetUserData(WrenVM* vm)`
fn C.wrenGetUserData(vm &C.WrenVM) voidptr

// get_user_data Returns the user data associated with the WrenVM.
pub fn get_user_data(vm &VM) voidptr {
	return C.wrenGetUserData(vm)
}

// C: `WREN_API void wrenSetUserData(WrenVM* vm, void* userData)`
fn C.wrenSetUserData(vm &C.WrenVM, user_data voidptr)

// set_user_data Sets user data associated with the WrenVM.
pub fn set_user_data(vm &VM, user_data voidptr) {
	C.wrenSetUserData(vm, user_data)
}
